pub fn run3() {
    /*
    テキスト領域（機械語に翻訳されたプログラム），静的領域はconst，文字列リテラルなどの静的変数
    スタック領域（コンパイル時に確保すべきメモリ量が決定できる変数：i32であれば4バイト必要，など）Rustでは8MBしかない LIFO
    ヒープ領域：動的に変化するデータ（string, vectorなど）
    メモリ管理：柔軟なメモリ管理が行える一方で，メモリリーク，二重解放などのバグの可能性が高まる．
    一方でプログラムが責任を持って確保と解放を行う場合はスピードが低速．
    所有権：メモリ上に存在する値を変数が所有するという考え方．所有権の移動や借用が行われる．コンパイル時に所有権チェックが行われる
    所有権のルール：1) 各値が所有者と呼ばれる変数に対応している．
    2) 値に対する所有者は必ず1つ．v2 = v1 とすると，v1に対応する値の所有権がv2に移る．
    3) 所有者がスコープから外れたら値は破棄される（つまりブロック内変数でブロックを抜けたら所有者が先に抜けるので値も消える）．
    メモリの生存期間（ライフタイム）が変数のスコープと同じになるので，コンパイル時に確定する．

    v1 = vec![1, 2, 3]とすると
    スタックにはptr len（長さ3） capacity（メモリ）→もしこの上限を超えたときに別の場所に移動する
    値のコピーには，v2 = v1.clone(); とする．コピー元のサイズは問題ないかなど注意が必要
    数値型や論理型などスタック領域に格納される値ではコピーが行われる．値をコピーしたとしても十分高速であると保証できるため



     */

    
    let a = 100;
    {
        let mut v1 = vec![1, 2, 3];
        println!("{:?}",v1);

        let mut v2 = v1; //この時点でvec!の所有権がv2に移動する
        println!("{:?}",v2);
        // println!("{:?}",v1); //これはエラーになる

        v2.push(4);
    }

}